#include "main.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "gba.h"

/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/SNAKE.h"
#include "images/fruitfinal.h"
#include "images/losescreen.h"
#include "images/winscreen.h"
/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state
{
  START,
  PLAY,
  WIN,
  LOSE,
};
void delay(int n)
{
  volatile int x = 0;
  for (int i = 0; i < n * 10000; i++)
  {
    x++;
  }
}
int main(void)
{
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  int score = 0;
  struct snake snake;
  snake.length = 1;
  snake.headlocation = 0;
  snake.sections[0].row = (HEIGHT) / 2 + 10;
  snake.sections[0].col = WIDTH / 2;
  // snake.taillocation = 0;

  int direction = 0; // deaful right

  struct apples fruits;
  fruits.count = 0;

  char reason[50] = "";

  while (1)
  {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state)
    {
    case START:
      waitForVBlank();
      drawFullScreenImageDMA(SNAKE);
      // drawCenteredString(HEIGHT/2, WIDTH/2, strlen("Press Start"), 1, "Press Start", WHITE);
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
      {
        state = PLAY;
        fillScreenDMA(BLACK);
        drawString(0, 0, "Score: ", WHITE);
        drawRectDMA(9, 0, WIDTH, 1, WHITE);
        score = 0;
        snake.length = 1;
        snake.headlocation = 0;

        direction = 0; // deaful right

        fruits.count = 0;

        for (int i = 0; i < 35; i++)
        {
          snake.sections[i].row = 0;
          snake.sections[i].col = 0;
        }
        snake.sections[0].row = (HEIGHT) / 2 + 10;
        snake.sections[0].col = WIDTH / 2;
      }
      //       if(KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
      // state = WIN;
      //       }

      break;

    case PLAY:
      // 0 = right
      // 1 = dpwmn
      // 2 = left
      // 3 = up

      // if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) && direction != 2) {
      if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && direction != 2)
      {
        // find diretions
        direction = 0;
      }
      // snake.sections[snake.headlocation + 1].row = snake.sections[snake.headlocation].row;
      // snake.sections[snake.headlocation + 1].col = snake.sections[snake.headlocation].col + 10;
      // snake.headlocation++;
      // } else if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) && direction != 3) {
      if (KEY_DOWN(BUTTON_DOWN, currentButtons) && direction != 3)
      {

        direction = 1;
      }
      // snake.sections[snake.headlocation + 1].row = snake.sections[snake.headlocation].row + 10;
      // snake.sections[snake.headlocation + 1].col = snake.sections[snake.headlocation].col;
      // snake.headlocation++;

      // } else if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) && direction != 0) {
      if (KEY_DOWN(BUTTON_LEFT, currentButtons) && direction != 0)
      {

        direction = 2;
      }
      // snake.sections[snake.headlocation + 1].row = snake.sections[snake.headlocation].row;
      // snake.sections[snake.headlocation + 1].col = snake.sections[snake.headlocation].col - 10;
      // snake.headlocation++;

      // } else if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) && direction != 1) {
      if (KEY_DOWN(BUTTON_UP, currentButtons) && direction != 1)
      {

        direction = 3;
      }
      // snake.sections[snake.headlocation + 1].row = snake.sections[snake.headlocation].row - 10;
      // snake.sections[snake.headlocation + 1].col = snake.sections[snake.headlocation].col;
      // snake.headlocation++;

      // moving
      //  directions converted into movement
      if (direction == 0)
      {
        snake.sections[(snake.headlocation + 1) % 35].row = snake.sections[snake.headlocation].row;
        snake.sections[(snake.headlocation + 1) % 35].col = snake.sections[snake.headlocation].col + 10;
        snake.headlocation = (snake.headlocation + 1) % 35;
      }
      else if (direction == 1)
      {
        snake.sections[(snake.headlocation + 1) % 35].row = snake.sections[snake.headlocation].row + 10;
        snake.sections[(snake.headlocation + 1) % 35].col = snake.sections[snake.headlocation].col;
        snake.headlocation = (snake.headlocation + 1) % 35;
      }
      else if (direction == 2)
      {
        snake.sections[(snake.headlocation + 1) % 35].row = snake.sections[snake.headlocation].row;
        snake.sections[(snake.headlocation + 1) % 35].col = snake.sections[snake.headlocation].col - 10;
        snake.headlocation = (snake.headlocation + 1) % 35;
      }
      else if (direction == 3)
      {
        snake.sections[(snake.headlocation + 1) % 35].row = snake.sections[snake.headlocation].row - 10;
        snake.sections[(snake.headlocation + 1) % 35].col = snake.sections[snake.headlocation].col;
        snake.headlocation = (snake.headlocation + 1) % 35;
      }

      // check collisions w/ border
      if (snake.sections[snake.headlocation].row < 10 || snake.sections[snake.headlocation].row > HEIGHT - 10 || snake.sections[snake.headlocation].col < 0 || snake.sections[snake.headlocation].col > WIDTH - 10)
      {
        state = LOSE;
        sprintf(reason, "w: r%d,c%d H%d W%d",
                snake.sections[snake.headlocation].row,
                snake.sections[snake.headlocation].col,
                HEIGHT, WIDTH);
        break;
      }
      // check body collisions
      for (int i = 1; i < snake.length; i++)
      {
        int Index = (snake.headlocation - i + 35) % 35;
        if (snake.sections[snake.headlocation].row == snake.sections[Index].row &&
            snake.sections[snake.headlocation].col == snake.sections[Index].col)
        {
          state = LOSE;
          reason[0] = 'b';
          break;
        }
      }

      // check fruit collisions
      int ate = 0;
      for (int i = 0; i < fruits.count; i++)
      {
        if (snake.sections[snake.headlocation].row == fruits.apples[i].row && snake.sections[snake.headlocation].col == fruits.apples[i].col)
        {
          score++;
          ate = 1;
          fruits.count--;
          for (int j = i; j < fruits.count; j++)
          {
            fruits.apples[j] = fruits.apples[j + 1];
          }
          i--;
          snake.length++;
        }
      }
      if (snake.length > 8)
      {
        state = WIN;
        break;
      }

      if (snake.length <= 0)
      {
        state = LOSE;
        break;
      }

      // check to readd fruit
      while (fruits.count < 5)
      {
        fruits.apples[fruits.count].col = (rand() % (WIDTH / 10)) * 10;
        fruits.apples[fruits.count].row = ((rand() % ((HEIGHT) / 10)) * 10) + 10;
        fruits.count++;
      }

      // drawing things
      waitForVBlank();
      drawRectDMA(0, 42, 30, 9, BLACK); // erase only the digits of score
      char scoreStr[20];
      sprintf(scoreStr, "%d", score);        // make score
      drawString(0, 6 * 7, scoreStr, WHITE); // draw

      // draw fruit
      for (int i = 0; i < fruits.count; i++)
      {
        drawImageDMA(fruits.apples[i].row, fruits.apples[i].col, 10, 10, fruitfinal);
      }
      // draw snake
      for (int i = 0; i < snake.length; i++)
      {
        int index = (snake.headlocation - i + 35) % 35;
        drawRectDMA(snake.sections[index].row, snake.sections[index].col, 10, 10, GREEN);
      }

      // score++;
      // if didnt grow in seiz remove tail
      if (ate == 0)
      {
        int tailIndex = (snake.headlocation - snake.length + 35) % 35;
        drawRectDMA(snake.sections[tailIndex].row, snake.sections[tailIndex].col, 10, 10, BLACK);
      }

      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
        score = 0;
      }
      delay(5 - snake.length / 2);
      break;

    case WIN:
      waitForVBlank();
      drawFullScreenImageDMA(winscreen);
      // char wintext[20];
      // sprintf(wintext, "YOU WIN");
      // drawString(10, 10, wintext, BLACK);

      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
        score = 0;
      }
      else
      {
        state = WIN;
      }

      break;
    case LOSE:
      waitForVBlank();
      drawFullScreenImageDMA(losescreen);
      // drawCenteredString(HEIGHT/2, WIDTH/2, 1, strlen("you lose :c"), "you lose :c", WHITE);

      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        state = START;
        score = 0;
      }
      else
      {
        state = LOSE;
      }
      break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
